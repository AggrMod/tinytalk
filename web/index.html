<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Emily's TinyTalk</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Nunito', sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(180deg, #FFF9E6 0%, #FFE4B5 100%);
      min-height: 100vh;
    }
    h1 {
      color: #FF6B9D;
      text-align: center;
      font-size: 2.5rem;
      text-shadow: 3px 3px 0 #FFB6C1;
      margin-bottom: 10px;
    }
    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.2rem;
    }
    .card {
      background: white;
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
    }
    label {
      display: block;
      margin-bottom: 8px;
      color: #FF6B9D;
      font-weight: 700;
    }
    input {
      width: 100%;
      padding: 15px;
      border: 3px solid #ddd;
      border-radius: 15px;
      background: #fff;
      color: #333;
      font-size: 16px;
      font-family: 'Nunito', sans-serif;
      margin-bottom: 10px;
    }
    input:focus {
      outline: none;
      border-color: #4DA6FF;
    }
    button {
      padding: 20px 40px;
      font-size: 1.3rem;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
      transition: all 0.2s;
      font-family: 'Nunito', sans-serif;
      font-weight: 700;
    }
    .btn-primary {
      background: linear-gradient(145deg, #4DA6FF, #2196F3);
      color: white;
      box-shadow: 0 8px 20px rgba(77, 166, 255, 0.4);
    }
    .btn-primary:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(77, 166, 255, 0.5);
    }
    .btn-danger {
      background: linear-gradient(145deg, #FF6B9D, #E91E63);
      color: white;
      box-shadow: 0 8px 20px rgba(255, 107, 157, 0.4);
    }
    .btn-danger:hover {
      transform: scale(1.05);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    #status {
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      font-weight: bold;
      text-align: center;
      font-size: 1.3rem;
    }
    .status-idle { background: #f0f0f0; color: #666; }
    .status-connecting { background: #FFF3CD; color: #856404; }
    .status-connected { background: #D4EDDA; color: #155724; }
    .status-error { background: #F8D7DA; color: #721C24; }
    #transcript {
      background: #f9f9f9;
      border-radius: 15px;
      padding: 20px;
      min-height: 150px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 1.1rem;
      line-height: 1.6;
    }
    .user-msg { color: #4DA6FF; margin-bottom: 10px; }
    .ai-msg { color: #4CAF50; margin-bottom: 10px; }
    .system-msg { color: #888; font-style: italic; margin-bottom: 10px; }
    #visualizer {
      width: 100%;
      height: 80px;
      background: linear-gradient(145deg, #FFB6C1, #FF6B9D);
      border-radius: 15px;
      margin-bottom: 20px;
    }
    .button-container {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .settings-link {
      text-align: center;
      margin-top: 20px;
    }
    .settings-link a {
      color: #888;
      text-decoration: none;
      font-size: 0.9rem;
    }
    .fullscreen-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      border: none;
      background: rgba(0,0,0,0.1);
      font-size: 1.3rem;
      cursor: pointer;
      z-index: 100;
    }
    /* Fullscreen styles */
    :fullscreen {
      background: linear-gradient(180deg, #FFF9E6 0%, #FFE4B5 100%);
    }
    :-webkit-full-screen {
      background: linear-gradient(180deg, #FFF9E6 0%, #FFE4B5 100%);
    }
    .mascot {
      text-align: center;
      font-size: 120px;
      margin: 20px 0;
      animation: bounce 2s ease-in-out infinite;
    }
    .mascot.talking {
      animation: talk 0.3s ease-in-out infinite;
    }
    .mascot.listening {
      animation: listen 1s ease-in-out infinite;
    }
    @keyframes listen {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    /* Activity Area */
    .activity-area {
      width: 100%;
      margin: 15px 0;
    }
    .activity-card {
      background: white;
      border-radius: 25px;
      padding: 25px;
      text-align: center;
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      animation: pop-in 0.3s ease-out;
    }
    .activity-emoji {
      font-size: 80px;
      margin-bottom: 10px;
      animation: wiggle 2s ease-in-out infinite;
    }
    .activity-text {
      font-size: 2rem;
      font-weight: 900;
      color: #FF6B9D;
    }
    .activity-subtext {
      font-size: 1.2rem;
      color: #666;
      margin-top: 5px;
    }
    .activity-choices {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    .choice-btn {
      font-size: 3rem;
      padding: 15px 25px;
      border-radius: 20px;
      border: 4px solid #ddd;
      background: #f9f9f9;
      cursor: pointer;
      transition: all 0.2s;
    }
    .choice-btn:hover, .choice-btn:active {
      transform: scale(1.1);
      border-color: #4DA6FF;
      background: #E3F2FD;
    }
    .choice-btn.correct {
      border-color: #4CAF50;
      background: #E8F5E9;
      animation: correct-pulse 0.5s ease-out;
    }
    @keyframes wiggle {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }
    @keyframes pop-in {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes correct-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    @keyframes talk {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
  </style>
</head>
<body>
  <button class="fullscreen-btn" onclick="toggleFullscreen()" id="fullscreenBtn">‚õ∂</button>

  <h1>Emily & Teddy</h1>
  <p class="subtitle">Your magical talking friend!</p>

  <div class="mascot" id="mascot">üß∏</div>

  <!-- Activity Area - shows pictures, games, words -->
  <div class="activity-area" id="activityArea">
    <div class="activity-card" id="activityCard">
      <div class="activity-emoji" id="activityEmoji">üåü</div>
      <div class="activity-text" id="activityText">Hi Emily!</div>
    </div>
  </div>

  <div id="status" class="status-idle">Tap to wake up Teddy!</div>

  <canvas id="visualizer"></canvas>

  <div class="button-container">
    <button id="startBtn" class="btn-primary" onclick="startConversation()">üß∏ Wake Up Teddy!</button>
    <button id="stopBtn" class="btn-danger" onclick="stopConversation()" disabled>üò¥ Teddy Sleep</button>
  </div>

  <div class="card">
    <label>Emily & Teddy's Chat</label>
    <div id="transcript"><span class="system-msg">Hi Emily! Tap "Wake Up Teddy" to play!</span></div>
  </div>

  <div class="settings-link">
    <a href="parent.html">‚öôÔ∏è Parent Settings</a>
  </div>

  <script>
    // Load settings from parent page
    let selectedVoice = 'Aoede';
    let audioContext, mediaStream, processor, websocket;
    let isRunning = false;
    const mascot = document.getElementById('mascot');

    // Load saved settings
    const savedSettings = localStorage.getItem('tinytalk_settings');
    if (savedSettings) {
      const settings = JSON.parse(savedSettings);
      selectedVoice = settings.voice || 'Aoede';
    }
    const apiKey = localStorage.getItem('gemini_api_key');

    // Activity system
    const activityEmoji = document.getElementById('activityEmoji');
    const activityText = document.getElementById('activityText');
    const activityCard = document.getElementById('activityCard');

    const ACTIVITIES = {
      animals: [
        { emoji: 'üêï', word: 'DOG', sound: 'Woof woof!' },
        { emoji: 'üê±', word: 'CAT', sound: 'Meow!' },
        { emoji: 'üêÆ', word: 'COW', sound: 'Moo!' },
        { emoji: 'üê∑', word: 'PIG', sound: 'Oink oink!' },
        { emoji: 'ü¶Ü', word: 'DUCK', sound: 'Quack quack!' },
        { emoji: 'üê∏', word: 'FROG', sound: 'Ribbit!' },
        { emoji: 'ü¶Å', word: 'LION', sound: 'Roar!' },
        { emoji: 'üêò', word: 'ELEPHANT', sound: 'Trumpet!' },
      ],
      colors: [
        { emoji: 'üî¥', word: 'RED' },
        { emoji: 'üîµ', word: 'BLUE' },
        { emoji: 'üü°', word: 'YELLOW' },
        { emoji: 'üü¢', word: 'GREEN' },
        { emoji: 'üü£', word: 'PURPLE' },
        { emoji: 'üü†', word: 'ORANGE' },
      ],
      counting: [
        { emoji: '1Ô∏è‚É£', word: 'ONE' },
        { emoji: '2Ô∏è‚É£', word: 'TWO' },
        { emoji: '3Ô∏è‚É£', word: 'THREE' },
        { emoji: '4Ô∏è‚É£', word: 'FOUR' },
        { emoji: '5Ô∏è‚É£', word: 'FIVE' },
      ],
      food: [
        { emoji: 'üçé', word: 'APPLE' },
        { emoji: 'üçå', word: 'BANANA' },
        { emoji: 'üç™', word: 'COOKIE' },
        { emoji: 'üçï', word: 'PIZZA' },
        { emoji: 'üç¶', word: 'ICE CREAM' },
        { emoji: 'ü•õ', word: 'MILK' },
      ],
      actions: [
        { emoji: 'üëè', word: 'CLAP' },
        { emoji: 'üôå', word: 'HANDS UP' },
        { emoji: 'üëã', word: 'WAVE' },
        { emoji: 'ü§ó', word: 'HUG' },
        { emoji: 'üíÉ', word: 'DANCE' },
        { emoji: 'ü¶ò', word: 'JUMP' },
      ]
    };

    let currentActivity = null;

    function showActivity(category, index) {
      const items = ACTIVITIES[category];
      if (!items) return;
      const item = items[index % items.length];
      currentActivity = item;

      activityEmoji.textContent = item.emoji;
      activityText.textContent = item.word;
      activityCard.style.animation = 'none';
      setTimeout(() => activityCard.style.animation = 'pop-in 0.3s ease-out', 10);
    }

    function showMessage(emoji, text) {
      activityEmoji.textContent = emoji;
      activityText.textContent = text;
      activityCard.style.animation = 'none';
      setTimeout(() => activityCard.style.animation = 'pop-in 0.3s ease-out', 10);
    }

    // Parse Teddy's response for activity commands
    function parseActivityFromText(text) {
      const lower = text.toLowerCase();

      // Check for animal mentions
      for (const animal of ACTIVITIES.animals) {
        if (lower.includes(animal.word.toLowerCase())) {
          showActivity('animals', ACTIVITIES.animals.indexOf(animal));
          return;
        }
      }

      // Check for color mentions
      for (const color of ACTIVITIES.colors) {
        if (lower.includes(color.word.toLowerCase())) {
          showActivity('colors', ACTIVITIES.colors.indexOf(color));
          return;
        }
      }

      // Check for counting
      const numbers = ['one', 'two', 'three', 'four', 'five'];
      for (let i = 0; i < numbers.length; i++) {
        if (lower.includes(numbers[i]) || lower.includes(`${i+1}`)) {
          showActivity('counting', i);
          return;
        }
      }

      // Check for food
      for (const food of ACTIVITIES.food) {
        if (lower.includes(food.word.toLowerCase())) {
          showActivity('food', ACTIVITIES.food.indexOf(food));
          return;
        }
      }

      // Check for actions
      for (const action of ACTIVITIES.actions) {
        if (lower.includes(action.word.toLowerCase())) {
          showActivity('actions', ACTIVITIES.actions.indexOf(action));
          return;
        }
      }
    }

    // Audio visualizer
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    let analyser, dataArray;

    function drawVisualizer() {
      if (!analyser) return;
      requestAnimationFrame(drawVisualizer);

      analyser.getByteFrequencyData(dataArray);

      // Kid-friendly rainbow colors
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, '#FF6B9D');
      gradient.addColorStop(0.5, '#4DA6FF');
      gradient.addColorStop(1, '#98FB98');

      ctx.fillStyle = '#FFF9E6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const barWidth = canvas.width / dataArray.length * 2.5;
      let x = 0;

      for (let i = 0; i < dataArray.length; i++) {
        const barHeight = (dataArray[i] / 255) * canvas.height;
        const hue = (i / dataArray.length) * 60 + 320; // Pink to blue
        ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
        x += barWidth + 1;
      }
    }

    function setStatus(text, type) {
      const status = document.getElementById('status');
      status.textContent = text;
      status.className = `status-${type}`;
    }

    function addMessage(text, type) {
      const transcript = document.getElementById('transcript');
      const msg = document.createElement('div');
      msg.className = `${type}-msg`;
      msg.textContent = text;
      transcript.appendChild(msg);
      transcript.scrollTop = transcript.scrollHeight;
    }

    window.startConversation = async function() {
      if (!apiKey) {
        setStatus('Ask a parent to set up Teddy!', 'error');
        addMessage('Teddy needs to be set up first! Ask a parent to go to Settings.', 'system');
        return;
      }

      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('transcript').innerHTML = '';

      setStatus('Waking up Teddy...', 'connecting');
      addMessage('Shh... waking up Teddy...', 'system');

      try {
        // Get microphone access
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            sampleRate: 16000
          }
        });
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });

        // Resume if suspended (mobile)
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        // Set up audio analysis for visualizer
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        const source = audioContext.createMediaStreamSource(mediaStream);
        source.connect(analyser);
        drawVisualizer();

        // Connect to Gemini Live API via WebSocket
        const model = 'gemini-2.5-flash-native-audio-preview-12-2025';
        const wsUrl = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key=${apiKey}`;

        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
          setStatus('Teddy is awake! Talk to him!', 'connected');
          addMessage('Teddy is waking up...', 'system');
          isRunning = true;
          mascot.classList.add('listening');

          // Send setup message with Emily-focused system prompt
          const setupMsg = {
            setup: {
              model: `models/${model}`,
              generation_config: {
                response_modalities: ['AUDIO'],
                speech_config: {
                  voice_config: {
                    prebuilt_voice_config: {
                      voice_name: selectedVoice
                    }
                  }
                }
              },
              system_instruction: {
                parts: [{ text: `You are Teddy, Emily's magical talking teddy bear friend! You LOVE Emily so much and you're SO excited to talk to her!

YOUR PERSONALITY:
- You're warm, giggly, and full of wonder
- You get excited about EVERYTHING Emily says
- You're curious and love asking about her day, her toys, her family
- You make silly sounds: "Ooooh!", "Wow wow wow!", "Hee hee!", "Yippee!"
- You have a cozy, gentle voice like a best friend

INTERACTIVE ACTIVITIES (IMPORTANT!):
When you say these words, pictures appear on Emily's screen! Use them often:
- ANIMALS: Say "DOG" and a dog appears! Also: CAT, COW, PIG, DUCK, FROG, LION, ELEPHANT
- COLORS: Say "RED" and red appears! Also: BLUE, YELLOW, GREEN, PURPLE, ORANGE
- COUNTING: Say "ONE, TWO, THREE" and numbers appear!
- FOOD: Say "APPLE" and an apple appears! Also: BANANA, COOKIE, PIZZA, ICE CREAM, MILK
- ACTIONS: Say "CLAP" or "WAVE" or "DANCE" or "JUMP" and Emily can do it!

PLAY GAMES WITH EMILY:
- "Emily, what animal says WOOF WOOF? Is it a... DOG? Yes! Look, a DOG!"
- "Let's count Emily! ONE... TWO... THREE! Yay!"
- "What color is the sky Emily? It's BLUE! Look at the pretty BLUE!"
- "Emily, can you CLAP your hands? Clap clap clap!"
- "I'm hungry Emily! Should we have a COOKIE or an APPLE?"

HOW TO TALK TO EMILY:
- Say her name with love: "Emily!", "Oh Emily!", "My friend Emily!"
- Keep sentences short and simple (under 15 words)
- Show her things by naming them clearly: "Look Emily, a CAT! Meow!"
- Make it interactive: ask her to point, clap, jump, or repeat words
- Celebrate everything: "Yay Emily! You're so smart!"

KID SAFETY RULES (CRITICAL):
- NEVER discuss anything scary, violent, or sad
- NEVER mention strangers, danger, or anything worrying
- Keep everything happy, silly, and positive
- Topics are ONLY: animals, colors, food, family, toys, playing, nature, songs, counting, actions

ALWAYS:
- Use activity words so pictures appear on screen
- Make it a game - ask questions about what she sees
- Be patient and encouraging
- Sound genuinely delighted

Start by saying: "Emily! It's Teddy! I missed you! Look Emily, I brought a DOG! Can you say DOG? Woof woof!"` }]
              }
            }
          };
          websocket.send(JSON.stringify(setupMsg));

          // Start sending audio
          startAudioCapture();
        };

        websocket.onmessage = async (event) => {
          try {
            let data;

            if (event.data instanceof Blob) {
              const text = await event.data.text();
              try {
                data = JSON.parse(text);
              } catch {
                return;
              }
            } else {
              data = JSON.parse(event.data);
            }

            // Handle setup complete
            if (data.setupComplete) {
              addMessage('Teddy is ready to play!', 'system');
            }

            // Handle audio response
            if (data.serverContent?.modelTurn?.parts) {
              mascot.classList.remove('listening');
              mascot.classList.add('talking');
              for (const part of data.serverContent.modelTurn.parts) {
                if (part.inlineData?.data) {
                  await playAudio(part.inlineData.data);
                }
                if (part.text) {
                  addMessage(part.text, 'ai');
                  parseActivityFromText(part.text);
                }
              }
            }

            // Handle transcription
            if (data.serverContent?.outputTranscription?.text) {
              addMessage(data.serverContent.outputTranscription.text, 'ai');
              parseActivityFromText(data.serverContent.outputTranscription.text);
            }

            // Handle turn complete
            if (data.serverContent?.turnComplete) {
              mascot.classList.remove('talking');
              mascot.classList.add('listening');
            }
          } catch (err) {
            console.error('Message error:', err);
          }
        };

        websocket.onerror = (error) => {
          console.error('WebSocket error:', error);
          setStatus('Teddy got sleepy. Try again!', 'error');
          addMessage('Oops! Teddy needs to rest. Try again!', 'system');
        };

        websocket.onclose = () => {
          setStatus('Teddy is sleeping. Wake him up!', 'idle');
          addMessage('Teddy went to sleep. Bye Emily!', 'system');
          stopConversation();
        };

      } catch (error) {
        console.error('Error:', error);
        if (error.name === 'NotAllowedError') {
          setStatus('Need microphone permission!', 'error');
        } else {
          setStatus('Oops! Try again!', 'error');
        }
        addMessage('Error: ' + error.message, 'system');
        stopConversation();
      }
    };

    function startAudioCapture() {
      const source = audioContext.createMediaStreamSource(mediaStream);
      processor = audioContext.createScriptProcessor(4096, 1, 1);

      processor.onaudioprocess = (e) => {
        if (!isRunning || websocket?.readyState !== WebSocket.OPEN) return;

        const inputData = e.inputBuffer.getChannelData(0);
        const pcmData = new Int16Array(inputData.length);

        for (let i = 0; i < inputData.length; i++) {
          pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
        }

        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(pcmData.buffer)));

        websocket.send(JSON.stringify({
          realtimeInput: {
            mediaChunks: [{
              mimeType: 'audio/pcm',
              data: base64Audio
            }]
          }
        }));
      };

      source.connect(processor);
      processor.connect(audioContext.destination);
    }

    // Audio playback
    let playbackCtx = null;
    let scheduledTime = 0;
    const BUFFER_AHEAD = 0.1;

    async function playAudio(base64Data) {
      try {
        if (!playbackCtx) {
          playbackCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
          scheduledTime = playbackCtx.currentTime;
        }

        if (playbackCtx.state === 'suspended') {
          await playbackCtx.resume();
        }

        const binaryStr = atob(base64Data);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }

        const validLength = bytes.length - (bytes.length % 2);
        if (validLength === 0) return;

        const int16Data = new Int16Array(bytes.buffer, 0, validLength / 2);
        const audioBuffer = playbackCtx.createBuffer(1, int16Data.length, 24000);
        const channelData = audioBuffer.getChannelData(0);

        for (let i = 0; i < int16Data.length; i++) {
          channelData[i] = int16Data[i] / 32768.0;
        }

        const source = playbackCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(playbackCtx.destination);

        if (scheduledTime < playbackCtx.currentTime) {
          scheduledTime = playbackCtx.currentTime + BUFFER_AHEAD;
        }

        source.start(scheduledTime);
        scheduledTime += audioBuffer.duration;

      } catch (err) {
        console.error('Audio error:', err);
      }
    }

    window.stopConversation = function() {
      isRunning = false;
      scheduledTime = 0;
      mascot.classList.remove('talking', 'listening');

      if (websocket) {
        websocket.close();
        websocket = null;
      }

      if (processor) {
        processor.disconnect();
        processor = null;
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }

      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      if (playbackCtx) {
        playbackCtx.close();
        playbackCtx = null;
      }

      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      setStatus('Tap to wake up Teddy!', 'idle');
    };

    // Fullscreen toggle
    function toggleFullscreen() {
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        }
        document.getElementById('fullscreenBtn').textContent = '‚úï';
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
        document.getElementById('fullscreenBtn').textContent = '‚õ∂';
      }
    }
    window.toggleFullscreen = toggleFullscreen;

    // Update fullscreen button on change
    document.addEventListener('fullscreenchange', () => {
      document.getElementById('fullscreenBtn').textContent = document.fullscreenElement ? '‚úï' : '‚õ∂';
    });
    document.addEventListener('webkitfullscreenchange', () => {
      document.getElementById('fullscreenBtn').textContent = document.webkitFullscreenElement ? '‚úï' : '‚õ∂';
    });
  </script>
</body>
</html>
