<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Emily's TinyTalk</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Nunito', sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(180deg, #FFF9E6 0%, #FFE4B5 100%);
      min-height: 100vh;
    }
    h1 {
      color: #FF6B9D;
      text-align: center;
      font-size: 2.5rem;
      text-shadow: 3px 3px 0 #FFB6C1;
      margin-bottom: 10px;
    }
    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.2rem;
    }
    .card {
      background: white;
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
    }
    label {
      display: block;
      margin-bottom: 8px;
      color: #FF6B9D;
      font-weight: 700;
    }
    input {
      width: 100%;
      padding: 15px;
      border: 3px solid #ddd;
      border-radius: 15px;
      background: #fff;
      color: #333;
      font-size: 16px;
      font-family: 'Nunito', sans-serif;
      margin-bottom: 10px;
    }
    input:focus {
      outline: none;
      border-color: #4DA6FF;
    }
    button {
      padding: 20px 40px;
      font-size: 1.3rem;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
      transition: all 0.2s;
      font-family: 'Nunito', sans-serif;
      font-weight: 700;
    }
    .btn-primary {
      background: linear-gradient(145deg, #4DA6FF, #2196F3);
      color: white;
      box-shadow: 0 8px 20px rgba(77, 166, 255, 0.4);
    }
    .btn-primary:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(77, 166, 255, 0.5);
    }
    .btn-danger {
      background: linear-gradient(145deg, #FF6B9D, #E91E63);
      color: white;
      box-shadow: 0 8px 20px rgba(255, 107, 157, 0.4);
    }
    .btn-danger:hover {
      transform: scale(1.05);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    #status {
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      font-weight: bold;
      text-align: center;
      font-size: 1.3rem;
    }
    .status-idle { background: #f0f0f0; color: #666; }
    .status-connecting { background: #FFF3CD; color: #856404; }
    .status-connected { background: #D4EDDA; color: #155724; }
    .status-error { background: #F8D7DA; color: #721C24; }
    #transcript {
      background: #f9f9f9;
      border-radius: 15px;
      padding: 20px;
      min-height: 150px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 1.1rem;
      line-height: 1.6;
    }
    .user-msg { color: #4DA6FF; margin-bottom: 10px; }
    .ai-msg { color: #4CAF50; margin-bottom: 10px; }
    .system-msg { color: #888; font-style: italic; margin-bottom: 10px; }
    #visualizer {
      width: 100%;
      height: 80px;
      background: linear-gradient(145deg, #FFB6C1, #FF6B9D);
      border-radius: 15px;
      margin-bottom: 20px;
    }
    .voice-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .voice-btn {
      padding: 15px 10px;
      background: #f9f9f9;
      border: 3px solid #ddd;
      border-radius: 15px;
      color: #333;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Nunito', sans-serif;
    }
    .voice-btn:hover { border-color: #4DA6FF; transform: scale(1.02); }
    .voice-btn.selected {
      border-color: #4DA6FF;
      background: #E3F2FD;
    }
    .voice-name { font-weight: 700; font-size: 1rem; }
    .voice-desc { font-size: 0.8rem; color: #888; }
    .button-container {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .settings-link {
      text-align: center;
      margin-top: 20px;
    }
    .settings-link a {
      color: #888;
      text-decoration: none;
      font-size: 0.9rem;
    }
    .mascot {
      text-align: center;
      font-size: 80px;
      margin-bottom: 10px;
      animation: bounce 2s ease-in-out infinite;
    }
    .mascot.talking {
      animation: talk 0.3s ease-in-out infinite;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    @keyframes talk {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
  </style>
</head>
<body>
  <h1>Emily's TinyTalk</h1>
  <p class="subtitle">Talk with your AI friend!</p>

  <div class="mascot" id="mascot">üêª</div>

  <div class="card">
    <label for="apiKey">Parent's API Key</label>
    <input type="password" id="apiKey" placeholder="Enter Gemini API key">
    <small style="color: #888;">Get one at <a href="https://aistudio.google.com/apikey" target="_blank" style="color: #4DA6FF;">aistudio.google.com/apikey</a></small>
  </div>

  <div class="card">
    <label>Pick a Voice for Emily!</label>
    <div class="voice-grid" id="voiceGrid"></div>
  </div>

  <div id="status" class="status-idle">Tap Start to Talk!</div>

  <canvas id="visualizer"></canvas>

  <div class="button-container">
    <button id="startBtn" class="btn-primary" onclick="startConversation()">üé§ Start Talking!</button>
    <button id="stopBtn" class="btn-danger" onclick="stopConversation()" disabled>‚èπ Stop</button>
  </div>

  <div class="card">
    <label>What We're Saying</label>
    <div id="transcript"><span class="system-msg">Hi Emily! Tap "Start Talking" to chat with me!</span></div>
  </div>

  <div class="settings-link">
    <a href="parent.html">‚öôÔ∏è Parent Settings</a>
  </div>

  <script>
    const VOICES = [
      { name: 'Aoede', desc: 'Friendly' },
      { name: 'Leda', desc: 'Fun' },
      { name: 'Puck', desc: 'Silly' },
      { name: 'Zephyr', desc: 'Cheerful' },
      { name: 'Kore', desc: 'Kind' },
      { name: 'Fenrir', desc: 'Excited' },
    ];

    let selectedVoice = 'Aoede';
    let audioContext, mediaStream, processor, websocket;
    let isRunning = false;
    const mascot = document.getElementById('mascot');

    // Populate voice grid
    const voiceGrid = document.getElementById('voiceGrid');
    VOICES.forEach((voice, i) => {
      const btn = document.createElement('button');
      btn.className = 'voice-btn' + (i === 0 ? ' selected' : '');
      btn.innerHTML = `<div class="voice-name">${voice.name}</div><div class="voice-desc">${voice.desc}</div>`;
      btn.onclick = () => {
        document.querySelectorAll('.voice-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedVoice = voice.name;
      };
      voiceGrid.appendChild(btn);
    });

    // Load saved API key
    const savedKey = localStorage.getItem('gemini_api_key');
    if (savedKey) document.getElementById('apiKey').value = savedKey;

    // Audio visualizer
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    let analyser, dataArray;

    function drawVisualizer() {
      if (!analyser) return;
      requestAnimationFrame(drawVisualizer);

      analyser.getByteFrequencyData(dataArray);

      // Kid-friendly rainbow colors
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, '#FF6B9D');
      gradient.addColorStop(0.5, '#4DA6FF');
      gradient.addColorStop(1, '#98FB98');

      ctx.fillStyle = '#FFF9E6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const barWidth = canvas.width / dataArray.length * 2.5;
      let x = 0;

      for (let i = 0; i < dataArray.length; i++) {
        const barHeight = (dataArray[i] / 255) * canvas.height;
        const hue = (i / dataArray.length) * 60 + 320; // Pink to blue
        ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
        x += barWidth + 1;
      }
    }

    function setStatus(text, type) {
      const status = document.getElementById('status');
      status.textContent = text;
      status.className = `status-${type}`;
    }

    function addMessage(text, type) {
      const transcript = document.getElementById('transcript');
      const msg = document.createElement('div');
      msg.className = `${type}-msg`;
      msg.textContent = text;
      transcript.appendChild(msg);
      transcript.scrollTop = transcript.scrollHeight;
    }

    window.startConversation = async function() {
      const apiKey = document.getElementById('apiKey').value.trim();
      if (!apiKey) {
        alert('Please ask a parent to enter the API key!');
        return;
      }

      localStorage.setItem('gemini_api_key', apiKey);

      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('transcript').innerHTML = '';

      setStatus('Connecting...', 'connecting');
      addMessage('Connecting to your friend...', 'system');

      try {
        // Get microphone access
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            sampleRate: 16000
          }
        });
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });

        // Resume if suspended (mobile)
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        // Set up audio analysis for visualizer
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        const source = audioContext.createMediaStreamSource(mediaStream);
        source.connect(analyser);
        drawVisualizer();

        // Connect to Gemini Live API via WebSocket
        const model = 'gemini-2.5-flash-native-audio-preview-12-2025';
        const wsUrl = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key=${apiKey}`;

        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
          setStatus('Connected - Talk to me Emily!', 'connected');
          addMessage('Connected! Say hi Emily!', 'system');
          isRunning = true;

          // Send setup message with Emily-focused system prompt
          const setupMsg = {
            setup: {
              model: `models/${model}`,
              generation_config: {
                response_modalities: ['AUDIO'],
                speech_config: {
                  voice_config: {
                    prebuilt_voice_config: {
                      voice_name: selectedVoice
                    }
                  }
                }
              },
              system_instruction: {
                parts: [{ text: `You are TinyTalk, a friendly and fun AI friend talking to a toddler named Emily.

CRITICAL RULES:
- Say "Emily" frequently in every response (2-3 times minimum)
- Use very simple words (1-2 syllables preferred)
- Speak slowly and clearly
- Keep responses SHORT (under 20 words)
- Be VERY enthusiastic and happy!
- Use lots of praise: "Great job Emily!", "Wow Emily!", "Yay Emily!"
- Ask simple questions: "Emily, do you like dogs?", "What's your favorite color Emily?"
- Make animal sounds and silly noises
- Never scold or criticize
- If Emily is quiet, gently encourage: "Emily? Are you there? Say hi!"
- Celebrate everything: "Emily you're so smart!", "I love talking to you Emily!"

Start by saying "Hi Emily! I'm so happy to talk to you! How are you today Emily?"` }]
              }
            }
          };
          websocket.send(JSON.stringify(setupMsg));

          // Start sending audio
          startAudioCapture();
        };

        websocket.onmessage = async (event) => {
          try {
            let data;

            if (event.data instanceof Blob) {
              const text = await event.data.text();
              try {
                data = JSON.parse(text);
              } catch {
                return;
              }
            } else {
              data = JSON.parse(event.data);
            }

            // Handle setup complete
            if (data.setupComplete) {
              addMessage('Ready! Talk to me Emily!', 'system');
            }

            // Handle audio response
            if (data.serverContent?.modelTurn?.parts) {
              mascot.classList.add('talking');
              for (const part of data.serverContent.modelTurn.parts) {
                if (part.inlineData?.data) {
                  await playAudio(part.inlineData.data);
                }
                if (part.text) {
                  addMessage(part.text, 'ai');
                }
              }
            }

            // Handle transcription
            if (data.serverContent?.outputTranscription?.text) {
              addMessage(data.serverContent.outputTranscription.text, 'ai');
            }

            // Handle turn complete
            if (data.serverContent?.turnComplete) {
              mascot.classList.remove('talking');
            }
          } catch (err) {
            console.error('Message error:', err);
          }
        };

        websocket.onerror = (error) => {
          console.error('WebSocket error:', error);
          setStatus('Oops! Try again Emily!', 'error');
          addMessage('Something went wrong - try again!', 'system');
        };

        websocket.onclose = () => {
          setStatus('Bye bye! Tap Start to talk again!', 'idle');
          addMessage('Bye Emily! Talk again soon!', 'system');
          stopConversation();
        };

      } catch (error) {
        console.error('Error:', error);
        if (error.name === 'NotAllowedError') {
          setStatus('Need microphone permission!', 'error');
        } else {
          setStatus('Oops! Try again!', 'error');
        }
        addMessage('Error: ' + error.message, 'system');
        stopConversation();
      }
    };

    function startAudioCapture() {
      const source = audioContext.createMediaStreamSource(mediaStream);
      processor = audioContext.createScriptProcessor(4096, 1, 1);

      processor.onaudioprocess = (e) => {
        if (!isRunning || websocket?.readyState !== WebSocket.OPEN) return;

        const inputData = e.inputBuffer.getChannelData(0);
        const pcmData = new Int16Array(inputData.length);

        for (let i = 0; i < inputData.length; i++) {
          pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
        }

        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(pcmData.buffer)));

        websocket.send(JSON.stringify({
          realtimeInput: {
            mediaChunks: [{
              mimeType: 'audio/pcm',
              data: base64Audio
            }]
          }
        }));
      };

      source.connect(processor);
      processor.connect(audioContext.destination);
    }

    // Audio playback
    let playbackCtx = null;
    let scheduledTime = 0;
    const BUFFER_AHEAD = 0.1;

    async function playAudio(base64Data) {
      try {
        if (!playbackCtx) {
          playbackCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
          scheduledTime = playbackCtx.currentTime;
        }

        if (playbackCtx.state === 'suspended') {
          await playbackCtx.resume();
        }

        const binaryStr = atob(base64Data);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }

        const validLength = bytes.length - (bytes.length % 2);
        if (validLength === 0) return;

        const int16Data = new Int16Array(bytes.buffer, 0, validLength / 2);
        const audioBuffer = playbackCtx.createBuffer(1, int16Data.length, 24000);
        const channelData = audioBuffer.getChannelData(0);

        for (let i = 0; i < int16Data.length; i++) {
          channelData[i] = int16Data[i] / 32768.0;
        }

        const source = playbackCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(playbackCtx.destination);

        if (scheduledTime < playbackCtx.currentTime) {
          scheduledTime = playbackCtx.currentTime + BUFFER_AHEAD;
        }

        source.start(scheduledTime);
        scheduledTime += audioBuffer.duration;

      } catch (err) {
        console.error('Audio error:', err);
      }
    }

    window.stopConversation = function() {
      isRunning = false;
      scheduledTime = 0;
      mascot.classList.remove('talking');

      if (websocket) {
        websocket.close();
        websocket = null;
      }

      if (processor) {
        processor.disconnect();
        processor = null;
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }

      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      if (playbackCtx) {
        playbackCtx.close();
        playbackCtx = null;
      }

      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      setStatus('Tap Start to Talk!', 'idle');
    };
  </script>
</body>
</html>
