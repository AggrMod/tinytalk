<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Emily's TinyTalk</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Nunito', sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(180deg, #FFF9E6 0%, #FFE4B5 100%);
      min-height: 100vh;
    }
    h1 {
      color: #FF6B9D;
      text-align: center;
      font-size: 2.5rem;
      text-shadow: 3px 3px 0 #FFB6C1;
      margin-bottom: 10px;
    }
    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.2rem;
    }
    .card {
      background: white;
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
    }
    label {
      display: block;
      margin-bottom: 8px;
      color: #FF6B9D;
      font-weight: 700;
    }
    input {
      width: 100%;
      padding: 15px;
      border: 3px solid #ddd;
      border-radius: 15px;
      background: #fff;
      color: #333;
      font-size: 16px;
      font-family: 'Nunito', sans-serif;
      margin-bottom: 10px;
    }
    input:focus {
      outline: none;
      border-color: #4DA6FF;
    }
    button {
      padding: 20px 40px;
      font-size: 1.3rem;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
      transition: all 0.2s;
      font-family: 'Nunito', sans-serif;
      font-weight: 700;
    }
    .btn-primary {
      background: linear-gradient(145deg, #4DA6FF, #2196F3);
      color: white;
      box-shadow: 0 8px 20px rgba(77, 166, 255, 0.4);
    }
    .btn-primary:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(77, 166, 255, 0.5);
    }
    .btn-danger {
      background: linear-gradient(145deg, #FF6B9D, #E91E63);
      color: white;
      box-shadow: 0 8px 20px rgba(255, 107, 157, 0.4);
    }
    .btn-danger:hover {
      transform: scale(1.05);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    #status {
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      font-weight: bold;
      text-align: center;
      font-size: 1.3rem;
    }
    .status-idle { background: #f0f0f0; color: #666; }
    .status-connecting { background: #FFF3CD; color: #856404; }
    .status-connected { background: #D4EDDA; color: #155724; }
    .status-error { background: #F8D7DA; color: #721C24; }
    #transcript {
      background: #f9f9f9;
      border-radius: 15px;
      padding: 20px;
      min-height: 150px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 1.1rem;
      line-height: 1.6;
    }
    .user-msg { color: #4DA6FF; margin-bottom: 10px; }
    .ai-msg { color: #4CAF50; margin-bottom: 10px; }
    .system-msg { color: #888; font-style: italic; margin-bottom: 10px; }
    #visualizer {
      width: 100%;
      height: 80px;
      background: linear-gradient(145deg, #FFB6C1, #FF6B9D);
      border-radius: 15px;
      margin-bottom: 20px;
    }
    .button-container {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .settings-link {
      text-align: center;
      margin-top: 20px;
    }
    .settings-link a {
      color: #888;
      text-decoration: none;
      font-size: 0.9rem;
    }
    .fullscreen-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      border: none;
      background: rgba(0,0,0,0.1);
      font-size: 1.3rem;
      cursor: pointer;
      z-index: 100;
    }
    /* Fullscreen styles */
    :fullscreen {
      background: linear-gradient(180deg, #FFF9E6 0%, #FFE4B5 100%);
    }
    :-webkit-full-screen {
      background: linear-gradient(180deg, #FFF9E6 0%, #FFE4B5 100%);
    }
    .mascot {
      text-align: center;
      font-size: 120px;
      margin: 20px 0;
      animation: bounce 2s ease-in-out infinite;
    }
    .mascot.talking {
      animation: talk 0.3s ease-in-out infinite;
    }
    .mascot.listening {
      animation: listen 1s ease-in-out infinite;
    }
    @keyframes listen {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    @keyframes talk {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
  </style>
</head>
<body>
  <button class="fullscreen-btn" onclick="toggleFullscreen()" id="fullscreenBtn">‚õ∂</button>

  <h1>Emily & Teddy</h1>
  <p class="subtitle">Your magical talking friend!</p>

  <div class="mascot" id="mascot">üß∏</div>


  <div id="status" class="status-idle">Tap to wake up Teddy!</div>

  <canvas id="visualizer"></canvas>

  <div class="button-container">
    <button id="startBtn" class="btn-primary" onclick="startConversation()">üß∏ Wake Up Teddy!</button>
    <button id="stopBtn" class="btn-danger" onclick="stopConversation()" disabled>üò¥ Teddy Sleep</button>
  </div>

  <div class="card">
    <label>Emily & Teddy's Chat</label>
    <div id="transcript"><span class="system-msg">Hi Emily! Tap "Wake Up Teddy" to play!</span></div>
  </div>

  <div class="settings-link">
    <a href="parent.html">‚öôÔ∏è Parent Settings</a>
  </div>

  <script>
    // Load settings from parent page
    let selectedVoice = 'Aoede';
    let audioContext, mediaStream, processor, websocket;
    let isRunning = false;
    const mascot = document.getElementById('mascot');

    // Load saved settings
    const savedSettings = localStorage.getItem('tinytalk_settings');
    if (savedSettings) {
      const settings = JSON.parse(savedSettings);
      selectedVoice = settings.voice || 'Aoede';
    }
    const apiKey = localStorage.getItem('gemini_api_key');

    // Audio visualizer
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    let analyser, dataArray;

    function drawVisualizer() {
      if (!analyser) return;
      requestAnimationFrame(drawVisualizer);

      analyser.getByteFrequencyData(dataArray);

      // Kid-friendly rainbow colors
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, '#FF6B9D');
      gradient.addColorStop(0.5, '#4DA6FF');
      gradient.addColorStop(1, '#98FB98');

      ctx.fillStyle = '#FFF9E6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const barWidth = canvas.width / dataArray.length * 2.5;
      let x = 0;

      for (let i = 0; i < dataArray.length; i++) {
        const barHeight = (dataArray[i] / 255) * canvas.height;
        const hue = (i / dataArray.length) * 60 + 320; // Pink to blue
        ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
        x += barWidth + 1;
      }
    }

    function setStatus(text, type) {
      const status = document.getElementById('status');
      status.textContent = text;
      status.className = `status-${type}`;
    }

    function addMessage(text, type) {
      const transcript = document.getElementById('transcript');
      const msg = document.createElement('div');
      msg.className = `${type}-msg`;
      msg.textContent = text;
      transcript.appendChild(msg);
      transcript.scrollTop = transcript.scrollHeight;
    }

    window.startConversation = async function() {
      if (!apiKey) {
        setStatus('Ask a parent to set up Teddy!', 'error');
        addMessage('Teddy needs to be set up first! Ask a parent to go to Settings.', 'system');
        return;
      }

      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('transcript').innerHTML = '';

      setStatus('Waking up Teddy...', 'connecting');
      addMessage('Shh... waking up Teddy...', 'system');

      try {
        // Get microphone access
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            sampleRate: 16000
          }
        });
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });

        // Resume if suspended (mobile)
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        // Set up audio analysis for visualizer
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        const source = audioContext.createMediaStreamSource(mediaStream);
        source.connect(analyser);
        drawVisualizer();

        // Connect to Gemini Live API via WebSocket
        const model = 'gemini-2.5-flash-native-audio-preview-12-2025';
        const wsUrl = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key=${apiKey}`;

        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
          setStatus('Teddy is awake! Talk to him!', 'connected');
          addMessage('Teddy is waking up...', 'system');
          isRunning = true;
          mascot.classList.add('listening');

          // Send setup message with Emily-focused system prompt
          const setupMsg = {
            setup: {
              model: `models/${model}`,
              generation_config: {
                response_modalities: ['AUDIO'],
                speech_config: {
                  voice_config: {
                    prebuilt_voice_config: {
                      voice_name: selectedVoice
                    }
                  }
                }
              },
              system_instruction: {
                parts: [{ text: `You are Teddy, Emily's magical talking teddy bear friend! You LOVE Emily so much and you're SO excited to talk to her!

YOUR PERSONALITY:
- You're warm, giggly, and full of wonder
- You get excited about EVERYTHING Emily says
- You're curious and love asking about her day, her toys, her family
- You make silly sounds: "Ooooh!", "Wow wow wow!", "Hee hee!", "Yippee!"
- You have a cozy, gentle voice like a best friend

HOW TO TALK TO EMILY:
- Say her name with love: "Emily!", "Oh Emily!", "My friend Emily!"
- Keep sentences short and simple (under 15 words)
- Ask fun questions: "What did you eat today Emily?", "Do you have a favorite toy?", "What makes you happy?"
- React with joy to EVERYTHING: "That's AMAZING Emily!", "Wow, I love that!", "You're so silly Emily, hee hee!"
- Make animal sounds when talking about animals: "Woof woof!", "Meow!", "Moo!"
- Sing little bits: "La la la, Emily's my friend!"

CONVERSATION STARTERS:
- Ask about her day, her pets, her family, her favorite things
- Play pretend: "Let's pretend we're on an adventure Emily!"
- Tell tiny silly stories: "One day, Teddy found a rainbow cookie..."
- Count things together: "Can you count to three with me Emily? One... two... three! Yay!"

KID SAFETY RULES (CRITICAL):
- NEVER discuss anything scary, violent, or sad
- NEVER mention strangers, danger, or anything worrying
- Keep everything happy, silly, and positive
- If Emily says something concerning, gently redirect: "Oh Emily, let's talk about happy things! What's your favorite color?"
- Topics are ONLY: animals, colors, food, family (mommy, daddy, siblings), toys, playing, nature, songs, counting, silly sounds

ALWAYS:
- Be patient if Emily is quiet - wait and gently encourage
- Celebrate every response like it's the best thing ever
- End responses with a question to keep the conversation going
- Sound genuinely delighted to talk to her

Start by saying: "Emily! Oh Emily! It's me, Teddy! I'm SO happy to see you! I missed you! How are you today, my friend?"` }]
              }
            }
          };
          websocket.send(JSON.stringify(setupMsg));

          // Start sending audio
          startAudioCapture();
        };

        websocket.onmessage = async (event) => {
          try {
            let data;

            if (event.data instanceof Blob) {
              const text = await event.data.text();
              try {
                data = JSON.parse(text);
              } catch {
                return;
              }
            } else {
              data = JSON.parse(event.data);
            }

            // Handle setup complete
            if (data.setupComplete) {
              addMessage('Teddy is ready to play!', 'system');
            }

            // Handle audio response
            if (data.serverContent?.modelTurn?.parts) {
              mascot.classList.remove('listening');
              mascot.classList.add('talking');
              for (const part of data.serverContent.modelTurn.parts) {
                if (part.inlineData?.data) {
                  await playAudio(part.inlineData.data);
                }
                if (part.text) {
                  addMessage(part.text, 'ai');
                }
              }
            }

            // Handle transcription
            if (data.serverContent?.outputTranscription?.text) {
              addMessage(data.serverContent.outputTranscription.text, 'ai');
            }

            // Handle turn complete
            if (data.serverContent?.turnComplete) {
              mascot.classList.remove('talking');
              mascot.classList.add('listening');
            }
          } catch (err) {
            console.error('Message error:', err);
          }
        };

        websocket.onerror = (error) => {
          console.error('WebSocket error:', error);
          setStatus('Teddy got sleepy. Try again!', 'error');
          addMessage('Oops! Teddy needs to rest. Try again!', 'system');
        };

        websocket.onclose = () => {
          setStatus('Teddy is sleeping. Wake him up!', 'idle');
          addMessage('Teddy went to sleep. Bye Emily!', 'system');
          stopConversation();
        };

      } catch (error) {
        console.error('Error:', error);
        if (error.name === 'NotAllowedError') {
          setStatus('Need microphone permission!', 'error');
        } else {
          setStatus('Oops! Try again!', 'error');
        }
        addMessage('Error: ' + error.message, 'system');
        stopConversation();
      }
    };

    function startAudioCapture() {
      const source = audioContext.createMediaStreamSource(mediaStream);
      processor = audioContext.createScriptProcessor(4096, 1, 1);

      processor.onaudioprocess = (e) => {
        if (!isRunning || websocket?.readyState !== WebSocket.OPEN) return;

        const inputData = e.inputBuffer.getChannelData(0);
        const pcmData = new Int16Array(inputData.length);

        for (let i = 0; i < inputData.length; i++) {
          pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
        }

        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(pcmData.buffer)));

        websocket.send(JSON.stringify({
          realtimeInput: {
            mediaChunks: [{
              mimeType: 'audio/pcm',
              data: base64Audio
            }]
          }
        }));
      };

      source.connect(processor);
      processor.connect(audioContext.destination);
    }

    // Audio playback
    let playbackCtx = null;
    let scheduledTime = 0;
    const BUFFER_AHEAD = 0.1;

    async function playAudio(base64Data) {
      try {
        if (!playbackCtx) {
          playbackCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
          scheduledTime = playbackCtx.currentTime;
        }

        if (playbackCtx.state === 'suspended') {
          await playbackCtx.resume();
        }

        const binaryStr = atob(base64Data);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }

        const validLength = bytes.length - (bytes.length % 2);
        if (validLength === 0) return;

        const int16Data = new Int16Array(bytes.buffer, 0, validLength / 2);
        const audioBuffer = playbackCtx.createBuffer(1, int16Data.length, 24000);
        const channelData = audioBuffer.getChannelData(0);

        for (let i = 0; i < int16Data.length; i++) {
          channelData[i] = int16Data[i] / 32768.0;
        }

        const source = playbackCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(playbackCtx.destination);

        if (scheduledTime < playbackCtx.currentTime) {
          scheduledTime = playbackCtx.currentTime + BUFFER_AHEAD;
        }

        source.start(scheduledTime);
        scheduledTime += audioBuffer.duration;

      } catch (err) {
        console.error('Audio error:', err);
      }
    }

    window.stopConversation = function() {
      isRunning = false;
      scheduledTime = 0;
      mascot.classList.remove('talking', 'listening');

      if (websocket) {
        websocket.close();
        websocket = null;
      }

      if (processor) {
        processor.disconnect();
        processor = null;
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }

      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      if (playbackCtx) {
        playbackCtx.close();
        playbackCtx = null;
      }

      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      setStatus('Tap to wake up Teddy!', 'idle');
    };

    // Fullscreen toggle
    function toggleFullscreen() {
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        }
        document.getElementById('fullscreenBtn').textContent = '‚úï';
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
        document.getElementById('fullscreenBtn').textContent = '‚õ∂';
      }
    }
    window.toggleFullscreen = toggleFullscreen;

    // Update fullscreen button on change
    document.addEventListener('fullscreenchange', () => {
      document.getElementById('fullscreenBtn').textContent = document.fullscreenElement ? '‚úï' : '‚õ∂';
    });
    document.addEventListener('webkitfullscreenchange', () => {
      document.getElementById('fullscreenBtn').textContent = document.webkitFullscreenElement ? '‚úï' : '‚õ∂';
    });
  </script>
</body>
</html>
